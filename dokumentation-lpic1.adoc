# Dokumentation Schulung LPIC-1

## Montag

- Geschichte von Linux
- Manpages -> `man <kommando>` 
- grundlegende Kommandos (BASH):

---- 
touch
ls
cd
rm
mkdir
apropos
whereis
info
---- 

- Aufbau von Kommandos:

----
kommando [-o/--option]... [argument]...
----

## Dienstag

- Befehle Dateiverwaltung:
----
cp
cp  -r (rekursiv)
cp -a
mv
mv (kein -r noetig)
rm
rm -r
----

- absolute (beginnen immer mit einem `/`) und relative Pfadangaben
- Sonderzeichen: `*`, `?`, Leerzeichen
- Escapen von Sonderzeichen
- Suche innerhalb der Manpages
- Variablen (Vererbung/Subshells)
- Kommando `export`
- Ausgabe des Inhalts von Variablen mit `echo $varname`
- Kommanod `env`
- `git`

## Mittoch

- Aufbau Shell-Prompt (Variable `PS1`)
- Definition eigener Aliase (in `.bash_aliases`)
- "Sicherheitseinstellungen" für `cp`, `rm` und `mv` (Option `-i`)
- Shell Builtins / externe Kommandos
- Pipe `|`
- `less`: Seitenweises Anzeigen von Dateien/Textstroemen
- persoenliche / systemweite Konfigurationsdateien: z.B. `~/.bashrc` bzw. `/etc/bash.bashrc`
- `!$`: hiermit kann das letzte Argument des zuletzt eingegebenen Kommandos aufgerufen werden:

----
# Datei editieren
nano ~/.bash_aliase

# Datei sourcen
. !$
source !$
----

- Verzeichnisse: 
  - `home`: beinhaltet die Heimatverzeichnisse der Benutzer
  - `etc`: beinhaltet *alle* systemweiten Konfigurationsdateien
  - `root`: Heimatverzeichnis des Benutzers `root`
  - `boot`: Dateien für den Bootloader, Linux Kernel etc.
- Kommanodsubstitution:
  - `echo $(kommando)`: kommando wird ausgeführt und das Ergebnis von `echo` ausgegeben
- `grep` sucht nach Suchbegriffen innerhalb von Dateien

### Textstroeme, Filter und Umleitungen
- Standardkanäle:
  - `stdin`: Kanal 0 - Eingabekanal 
  - `stdout`: Kanal 1 - Ausgabkanal 
  - `stderr`: Kanal 2 - Fehlerkanal 
- Umleitungen / Redirects:
  - Kanäle koennen in andere Kanaele oder Dateien umgeleitet werden
  - `>` Dateiinhalt wird ersetzt
  - `>>` neue Ausgabe wird an bestehende Datei angehängt
- Pipes `|`
  - die Ausgabe (Kanal 1) eines Kommandos wird an die Eingabe (Kanal 0) eines weiteren Programms geleitet

### UNIX Philosophie
- Schreibe Computerprogramme so, dass sie nur eine Aufgabe erledigen und diese gut machen.
- Schreibe Programme so, dass sie zusammenarbeiten.
- Schreibe Programme so, dass sie Textströme verarbeiten, denn das ist eine universelle Schnittstelle.
- vereinfacht: Mache nur eine Sache und mache sie gut.

## Donnerstag

### Berechtigungen

----
# reguläre Dateien
r = read    -> Dateiinhalt lesen
w = write   -> Dateiinhalt schreiben
x = execute -> Dateien ausführen 

# Verzeichnisse
r = read    -> Verzeichnisinhalt lesen
w = write   -> Dateien erstellen oder loeschen
x = execute -> Verzeichnis betreten/hineinwechseln

Filedescriptor Owner Group Others
                u      g    o
-	       rwx   rwx   rwx 
----

### Berechtigungen ändern

Der Besitzer einer Datei (oder `root`) koennen mit dem Kommando `chmod` Berechtigungen ändern

#### Symbolische Rechtevergabe

----
# (< und > sind Platzhalter)

chmod <user,group,other,all>+-=<read,write,execute> datei

chmod <u,g,o,a>+-=<r,w,e> datei

chmod u+w datei    # Schreibrecht für Besitzer hinzufügen

chmod g-rw datei   # Gruppe Lese- und Schreibrecht entziehen
chmod ug+rwx datei  # User und Gruppe alle Rechte hinzufügen
----


#### Oktale Rechtevergabe

----
 r = 4
 w = 2
 x = 1

 dez bin
 1   001
 2   010
 4   100


  6      5    
 rwx    rwx
 110    101
----

- Rechte koennen nur absolut, d.h. für Besitzer, Gruppe und Others gleichzeitig vergeben werden
- jedes Recht hat einen eigenen Wert
- Rechte werden über die Addition der Einzelwerte angesprochen
- Lese- und Schreibrecht resultiert also in der Addition von 4 (lesen) plus 2 (schreiben) -> 6 

### Gruppen

- es gibt zwei Arten von Gruppen: die initiale/primäre Gruppe eines Benutzers (heisst in der Regel genauso wie der Benutzer) und die zusätzlichen (_suplementary_) Gruppen
- wenn man einen Benutzer einer Gruppe hinzufügt, muss sich dieser einmal komplett ab- und wieder anmelden, damit die Gruppenzugehoerigkeit aktiv wird (Konfigurationsdatei `/etc/group` wird dann neu eingelesen


### sudo
- um einem Benutzer sudo-Rechte zu gewähren, kann dieser z.B. in die Gruppe `sudo` oder `wheel` (distributionsabhängig) hinzugefügt werden

### curl / wget
- CLI Programme zum Herunterladen ganzer Webseiten, Dateien, Bilder etc.
- Koennen auch zur Prüfung der Erreichbarkeit von Webseiten eingesetzt werden


## Montag

### 101.1 Hardwareeinstellungen / Boot Prozess

#### Komponenten Boot
1. Anschalten
2. BIOS (Basis Input Output System) / UEFI (Unified Extensible Firmware Interface) 
3. Power On Self Test (POST): grundlegender Hardwaretest
4. Bootloader (GRUB oder anderer)
5. OS (Linux-Kernel) wird gestartet
6. Kernelspace -> Userspace (`init` / `systemd`)

#### PCI

- `lspci` - Liste aller am PCI-Bus angeschlossener Geräte
- einzelne Geräte koennen über Bus angesprochen werden

#### USB 

- `lsusb` - Liste angeschlossener USB Geräte 
- einzelne Geräte koennen über ID oder Bus angesprochen werden

##### USB 1.1
- `usb-ohci.o` -> Open Host Controller Interface
- `usb-uhci.o` -> Universal Host...

##### USB 2.0
- `usb-ehci.o` -> Enhanced ...

##### USB 3
- `usb-xhci.o` -> Extensible ...
 
##### proc/ und sys/
- hier werden zur Laufzeit Informationen über Programme/Prozesse/System an sich hinterlegt
- diese koennen meist nur eingesehen, manchmal aber auch durch einfache Schreiboperationen (z.B. mit `echo` auf die gegebene Datei verändert werden (nur für aktuellen Bootvorgang))


### Dienstag

#### 103.5 Prozesse
- Was sind Prozesse
- Vordergrung/Hintergrund `bg`, `fg`, `<kommando> &`
- Prozesse überwachen mit `ps`, `jobs`, `top`
- Signale an Prozesse senden mit
  - `kill` bzw. `killall` und `pkill`
  - Tastenkombinationen `STRG+C`, `STRG+Z`
- PID herausfinden mit `pgrep`
- Prozesse von der aktuellen Shell "loesen":
  
  - Terminal Multiplexer `screen` (`tmux`, `byobu`)


### Mittwoch

#### locate
- sehr schnell, da Datenbank bei der Suche abgefragt wird
- diese muss erzeugt werden (wird automatisch vom System erledigt, periodisch -> `cron`)
- manuelle Aktualisierung mit `sudo updatedb` -> noetig, um neue Dateien über die Suche zu finden
- keine/wenige Moeglichkeiten, genauere Suchkriterien festzulegen

#### find
- durchsucht das Dateisystem an sich, kein Zugriff auf eine Datenbank
- Suchkriterien (_TESTs_ in der Manpage) koennen sehr fein eingestellt werden (Zeitpunkt letzte Dateiänderung, Groesse, Besitzverhältnisse, gesetzte Berechtigungen etc.)
- Suchkriterien/Optionen werden durch ein Minuszeichen und der Langform angegeben, z.B. `-name`, `-type`, etc. 
- als Suchbegriff kann ein Regulärer Ausdruck verwendet werden
- auf die einzelnen Suchergebnisse koennen Dateioperationen durchgeführt werden (`find ... -exec ls -l {} \;`)
- wird `find` als regulärer Benutzer ausgeführt und das gesamte Dateisystem durchsucht koennen/sollten die Fehler (fehlende Berechtigungen) über einen Redirect nach `/dev/null` umgeleitet werden: `find / -name "wasauchimmer" 2>/dev/null`

#### vi / vim
- `vi` ist der Standardeditor auf jedem Linuxsystem (vorinstalliert)
- `vim` -> ViImproved
- sehr eigenes Bedienkonzept (Normalmode, Insertmode, Commandmode, Visualmode ...)
- Tutorial mittels Kommando `vimtutor` aufrufbar

### Donnerstag

#### Regular Expressions

----
.       - Any Character Except New Line
\d	- Digit (0-9)
\D	- Not a Digit (every character except 0-9)
\s 	- any Whitespace (Space, Tab, Newline)
\S 	- Not a  Whitespace
\w	- Word character (a-z, A-Z, 0-9, _, -)
\W	- Not a Word character 


\b 	- word Boundary
^ 	- Zeilenanfang
$	- Zeilenende
----

##### Quantifier (act on previous symbol)
----
* 	- 0 or more
+	- 1 or more
?	- 0 or 1  /  optional
{n}	- exactly n times
{n,m}   - between n and m times
{n,}	- minimum n times
{,n}	- maximum n times
----

##### Character Sets / List of characters
----
[abc] 	- one of a, b or c
[0-9] 	- range from 0 to 9 <=> \d
[a-z] 	- range from a to z
[^a] 	- not a
|	- either or
----

##### Groups
----
()		- Group
(expr1|expr2)	- either expr1 or expr2
----


##### Examples
----
# RegEx
^\(?[0-9]{4}(\)\s|[.-])\d{6}$

# Matches
0561.807000
0561-807000
(0561) 807000

# Does not match
0561_807000
----

----
# RegEx
^https?://([a-z0-9]+\.)?([a-z0-9]+\.)?[a-z]{2,3}$
^https?://([a-z0-9]+\.)?([a-z0-9]+\.)?(de|com|org|eu)$

# matches:
https://gfn.de
https://www.gfn.de
http://mypage.com
https://www.google.eu
https://meine.haustiere.com

# does not match:
https://meine.haustiere
https://Meine.Haustiere.de
https://ätsch.de
http://_dontmatch.ch
https://*auchnicht.de
http://(nlll.lkj
https//no.org
https://gfn-de
htps:/bla.com
http://localhost
http://mocalhost
httpw://nonono
----

##### Links
- https://www.debuggex.com/  (Regex Editor mit grafischer Repräsentation)
- http://regexe.de/	(Regex Editor mit Suchen und Ersetzen)
- https://regexone.com/	(Regex Tutorial)
- https://www.regular-expressions.info/


## Freitag

### Partitionierung
- Kommandos `fdisk` (MBR, mittlerweile auch GPT), `gdisk` (nur GPT) -> interaktiv
- Änderunen werden erst übernommen, wenn `w` für _Schreiben_ gewählt wird
- `parted` ist ein weiteres Partitionierungstool
  - hier werden Ånderungen direkt durchgeführt (koennen aber mit `rescue` rückgängig gemacht werden)
  - es koennen hiermit auch Disklabels vergeben werden

### MBR / GPT
- im MBR befindet sich die Partitionstabelle (Anfang der Festplatte)
  - kann mit `dd` gesichert werden: `dd if=/dev/sda of=mbr.bak bs=512 count=1`
- es koennen maximal vier _primäre_ Partitionen erstellt werden
- eine dieser vier Partitionen kann als _erweiterte_ Partition definiert werden, diese kann dann weitere _logische_ Partitionen enthalten (erstel logische Partition hat immer die Nummer 5 -> `/dev/sda5`)
- weitere Beschränkungen im Vergleich zu GPT
- GPT speichert zusätzlich eine zweite Version/Kopie der Partitionstabelle

### Dateisysteme
- `ext4` ist das Standarddateisystem unter Linux 
- weitere Dateisystemem: ext2, ext3, xfs, btrfs, vfat, ...
- Dateisysteme erzeugen mit `mkfs` bzw. `mk2fs`
- `btrfs` bietet weitere Funktionalitäten wie z.B. Subvolumes, Snapshots etc.
- für die Verwendung weiterer Dateiesysteme müssen die entsprechenden Pakete installiert werden: `xfsprogs`, `btrfs-progs` ...
- mit `tune2fs` koennen Eigenschaften des Dateisystems verändert werden
  - z.B. Konvertierung von `ext2` nach `ext3`

### Mounten
- durch das Mounten wird die Gerätedatei (z.B. `/dev/sdb1`) mit einem Verzeichnis verknüpft (z.B. `/mnt`)
- nur so kann die Partition auch benutzt werden
- Kommando ist `mount <Gerätedatei> <existierendes Verzeichnis/Mountpoint>`
- die statische Konfiguration wird in der Datei `/etc/fstab` vorgenommen
  - Einträge, bei denen die Option `auto` gesetzt ist, werden beim Boot automatisch eingebunden, aber nicht im laufenden system
  - für "richtiges" Automount sind weitere Tools noetig
  - angegebene Optionen koennen sich überschreiben (Reihenfolge), nützlich, um `defaults` Optionen anzupassen
  - unbedingt auf richtige Syntax auchten, sonst kann es zu Problemen beim Booten kommen
- Dateisysteme müssen ordnungsgemäss entbunden werden: `umount`
  - hierfür darf sich das Gerät/Verzeichnis nicht mehr in Benutzung befinden (Überprüfung mit `lsof`)

## Montag

### SysV-Init
- altes Init System, Vorgänger von `systemd`, Prozess heisst `init` mit PID 1
- Startvorgang verläuft sequentiell, d.h. keine parallele Abarbeitung -> recht langsam
- Dienste/Startvorgang werden über Shell-Skripte konfiguriert/gestartet
- Kommando zur Steuerung von Diensten ist `service`: z.B. `service ssh status`
- Skripte liegen unter `/etc/init.d`

### Runlevel
- _Betriebszustände_ in denen sich das System befinden kann
- werden beim Bootvorgang durchlaufen
- es gibt die Runlevel 1 bis 6
- Runlevel werden in der Datei `/etc/inittab` definiert
  - Runlevel 0: Computer ausschalten
  - Runlevel 1: Single User Mode / Rescue Mode (vergleichbar mit dem _Abgesicherten Modus_
  - Runlevel 2: Multi User Mode
  - Runlevel 3: zusätzlich Netzerk
  - Runlevel 4: nicht genutzt
  - Runlevel 5: zusätzlich grafische Oberfläche
  - Runlevel 5: Reboot
- Definition ist nicht starr, kann angepasst werden
- in den Verzeichnissen `/etc/rc0.d` bis `/etc/rc6.d` liegen Symlinks auf Skripte, die Dienste starten bzw. stoppen
- Skripte/Dienste mit einem `S` am Anfang werden beim Betreten des Runlevel gestartet, solche mit einem `K` entsprechend gestoppt, Reihenfolge über Zahlen hinter `S` oder `K`
  
### systemd
- Nachfolger von SysV-Init
- Dienste werden beim Boot parallel gestartet
- Abhängigkeiten zu anderen Diensten koennen definiert werden
- Dienste werden nicht mehr über Shell Skripte, sondern über Unit Files konfiguriert
- Entsprechung zu den Runleveln sind _targets_, z.B. `rescue.target`, `graphical.target` etc.
  - `systemctl isolate rescue.target` um in den "Wartungsmodus" zu gelangen
- Unit Files liegen unter `/lib/systemd/system`, _aktive_ (per Symlink) unter `/etc/systemd/system/` (ähnliches Prinzip wie beim Apache `sites-available` und `sites-enabled`

### tar
- Archivierungstool: fasst mehrere Dateien zu einer einzigen zusammen
- Syntax gewoehungsbedürftig
- Beispiele:
  - Archiv erstellen: `tar -cvf myarchive.tar directory/ file1 file2`
  - Archiv extrahieren: `tar -xvf myarchive.tar`
  - gzip komprimiertes Archiv erstellen: `tar -cvzf myarchive.tar.gz dir/ file1`
  - bzip2 komprimiertes Archiv erstellen: `tar -cvjf myarchive.tar.bz2 dir/ file1`
  - xz komprimiertes Archiv erstellen: `tar -cvJf myarchive.tar.xz dir/ file1`
  - beim Extrahieren von komprimierten Archiven erkennt `tar` den Komprimierungsalgorythmus automatisch (kann aber auch angegeben werden)
  - Inhalt des Archivs anzeigen: `tar -tf archiv.tar`, `tar --list -f archive.tar`
- wird eine Datei angegeben (mit `-f`), muss das `-f` als letzte Option direkt vor dem Dateinamen stehen
  - ist bei der alten UNIX Syntax (ohne Minuszeichen) egal

### Kompression
- nur einzelne Dateien koennen komprimiert werden, ansonsten vorher mit `tar` ein Archiv erstellen
- die Originaldatei wird durch die komprimierte ersetzt
- gzip / gunzip
- bzip2 / bunzip
- xz /unxz
- (compress)

## Dienstag

### Paketverwaltung Debian

#### dpkg
- dpkg: Backend hinter `apt`
- kann  Pakete installieren, deinstallieren etc.
- Einschränkungen: keine Pakekte übers Internet installieren, kann keine Abhängigkeiten aufloesen, zeigt diese allerdings an
- im Verzeichnis `/var/lib/dpkg` befinden sich Dateien und Verzeichnisse, die eine Art Datenbank für `dpkg` (und `apt`) sind
- Informationen über Pakete, deren Zustand (installiert, teilweise installiert), verfügbare Pakete etc  finden sich hier
- `dpkg -i / --install <pfad-zum-deb-paket>`: installiert lokal vorhandenes Paket  
- `dpkg -Ri / --recursive --install <verzeichnis>`: installiert alle `*.deb` Pakete im Verzeichnis (rekursiv)
- `dpkg -r / --remove <paketname>`: Entfernt Paket, Konfigdateien bleiben erhalten  
- `dpkg -P / --purge <paketname>`: Paket und Konfigdateien werden entfernt  
- `dpkg -l / --list <suchbegriff>`: eine Liste aller Pakete, die auf einen Suchbegriff passen  
- `dpkg -L / --listfiles <paketname>`: listet alle Dateien auf, die ein Paket installiert
- `dpkg -S / --search <dateiname-absoluter Pfad>`: in welchem Paket befindet die angegebene Datei
- `dpkg -s / --status <paketname>`: Status des Paketes anzeigen  
- `dpkg -C / --audit`: alle Pakete, die nicht vollständig installiert sind
- `dpkg -c / --contents <deb-paket>`: zeigt Inhalt des Pakets an
- `dpkg-reconfigure <paketname>`: installiertes Paket neu konfigurieren (TUI Interface -> wird so auch bei der eigentlichen Installation aufgerufen)

#### apt-get / apt
- Frontend für `dpkt`
- kann  Pakete über das Internet herunterladen und installieren
- loest Abhängigkeiten automatisch auf
- nutz `dpkg` im Hintergrund 
- `apt-get` und `apt` in der Bedienung sehr ähnlich
- `apt` vereint "Unterprogramme" von `apt` (`apt-get`, `apt-cache`...) zu einem 
- `apt-get install`: Paket installieren
- `apt-get remove`: Paket entfernen (Konfigdateien bleiben erhalten)
- `apt-get remove --purge`: Paket und Konfigdateien entfernen
- `apt-get purge`: Paket und Konfigdateien entfernen
- `apt-get update`: Paketindex aktualisieren
- `apt-get upgrade`: aktualiert alle vorhandenen Pakete, es werden aber niemals neue Pakete als Abhängigkeit hinzugefügt oder entfernt (diese zurückgehaltene Pakete werden angezeigt)
- `apt-get dist-upgrade`: aktualisiert alle installierten Pakete (entfernt bzw. installiert ggf. zusätzlich Pakete aufgrund geänderter Abhängigkeiten) -> Unterschied zu `apt-get upgrade`, hiermit werden die von `apt-get upgrade` zurückgehaltenen Pakete installiert/aktualisiert
- `apt-cache policy`: installierte Version / Version im Paketindex anzeigen
- `apt-cache show`: detaillierte Inforamtionen über ein Paket
- `apt-cache serach`: nach einem Paket suchen
- `apt-cache depends`: welche Abhängigkeiten hat das Paket
- `apt-cache rdepends`: welche anderen Pakete hängen von diesem Paket ab
- `apt-cache stats`: Statistik über Cache/Paketindex
- `apt-get autoremove`: entfernt nicht mehr benoetigte Pakete, die *als Abhängigkeit automatisch* installiert wurden. In der Regel sicher zu nutzen, kann unter Umständen aber zu Problemen führen
- `apt-mark manual|auto|... <paket>`: Paket als manuell/explizit | automatisch installiert markieren
- `alien --to-rpm <deb-paket>`: wandelt `.deb` Paket in ein `.rpm` Paket um
- `alien --to-deb <rpm-paket>`: wandelt `.rpm` Paket in ein `.deb` Paket um

## Mittwoch

### RPM Paketverwaltun

#### rpm
- Backend hinter yum/dnf
- vergleichbar mit `dpkg`
- "Datenbank" unter `/var/lib/rpm` 
- `rpm -i / --install <paket.rpm>`: RPM Paket installieren 
- `prm -iv / -ivv / -ivv <datei.rpm>`: Installation _verbose_ verfolgen (Ausgabe der einzelnen Schritte auf `stdout`), kann auch mit anderen Optionen kombiniert werden  
- `rpm -e / --erase <paketname>`: Paket deinstallieren
- `rpm -U / --upgrade <paket.rpm>`: Paket aktualisieren bzw. installieren falls noch nicht vorhanden
- `rpm -F / --freshen <paket.rpm>`: Paket aktualisieren aber nicht installieren falls noch nicht vorhanden
- `rpm -h / --hash`: zeigt Fortschrittsbalken an
- `rpm --force`: erzwingt Aktion
- `rpm --nodeps`: keine Prüfung der Abhängigkeiten

##### Package Selection Options
- `rpm -q / --query <paketname>`: Anzeige `.rpm` Datei 
- `rpm -qa / --query --all`: Welche Pakete sind installiert

##### Package Query Options
- `rpm -qR / --query --requires <paketname>`: Abhängigkeiten auflisten
- `rpm -ql / --query --list <paketname>`: alle Dateien des Pakets auflisten
- `rpm -qi / --query --info <paketname>`: Informationen über Paket
- `rpm -qc / --query --configfiles <paketname>`: nur Konfigurationsdateien des Pakets anzeigen
- `rpm -qf / --query --file </pfad/zur/datei>`: zu welchem Paket gehoert `datei`
- `rpm -qd / --query --docfiles <paketname>`: Dokumentationsdateien eins installierten Paktes anzeigen
- `rpm -qdp / --query --docfiles --package <paket.rpm>`: Dokumentationsdatein eines nicht installierten Pakets anzeigen (`-p` auch auf andere Optionen anwendbar)
- `rpm -V / --verify <paket>`: Paketüberprüfung: nach z.B. geänderte Dateigroesse, MD5 Summer, Besitzrechte etc.
- `rpm -K / --checksig <paket.rpm>`: Signatur des Pakets vor der Installation prüfen (nicht prüfungsrelevant, zusätzlich muss GPG verwendet und konfiguriert werden)

#### cpio
- `rpm` kann keine Pakete entpacken, wir koennen aber mit `rpm2cpio` eine `cpio` Datei aus dem Paket erstellen und diese mit `cpio` entpacken: `rpm2cpio samba-3.3.2-0.33.rpm | cpio -idv usr/share/man/man7/samba.7` (entpackt nur die Datei `samba.7`, ohne Angabe Datei werden alle Dateien entpackt)

#### Yum / dnf
- Frontend für `rpm`, `dnf` ist der "Nachfolger" von `yum`
- Konfigurationsdatei unter `/etc/yum.conf`
- Cache Verzeichnis für z.B. heruntergeladene Pakete unter `/var/cache/dnf` (falls `dnf` im Hintergrund verwendet wird: mittlerweile Standard'
- `yum search`
- `yum update (paketname)`: Aktualisiert Paketindex *und* führt Aktualisierung der Pakete durch (Unterschied zu `apt`)
- `yum install`: Pakte installieren
- `yum remove`: Paket deinstallieren
- `yum grouplist`: Anzeige der Paketgruppen
- `yum groupinfo <paketgruppe>`: Info über paketgruppe
- `yum groupinstall <paketgruppe>`: Installation der Pakete aus der Paketgruppe
- `yum list <name>`: Liste der Pakete
- `yum list installed`: Liste der installierten Pakete
- `yum list updates`: verfügbare Updates
- `yum info <paket>`: Informationen über paket
- `yum clean`: Paketcache leeren
- `yum clean metadata`: Metadata des Paketcache leeren
- `yum clean all`: beides leeren
- `yum deplist <paket>`: Abhängigkeiten des Pakets
- `yumdownloader <paket>`: Lädt Paket herunter ohne zu installieren, Pfad kann angegeben werden `yumdownloader --dest-dir`

## Donnerstag

### sed
- der _Stream Editor_ `sed` kann alles das was `cat cut grep tail` können, universelles Kommando um Textströme zu bearbeiten, finden, anzeigen, ersetzen
-  `sed -n /Übung/p < tutor1`: Sucht den Suchbegriff `Übung` und gibt die entsprechenden Zeilen aus. 
- `-n` unterdrückt die automatische Ausgabe, `sed` gibt standardmässig alle Zeilen der Datei aus
- `sed "s/Übung/Lern/" < tutor1` ersetzt das erste Vorkommen von `Übung` in jeder Zeile  durch `Lern`
- es wird keine Änderung an der Datei vorgenommen, sondern nur im STDOUT Kanal
- `sed "s/Übung/Lern/g" < tutor1` ersetzt alle Vorkommnisse von `Übung` durch `Lern`` 
- durch `-i` (`--in-place`) wird die Datei geändert
- - `sed` koennen auch mehrere Dateien als Argumente übergeben werden
- `sed -i.backup 's/root/CV/g' ls-tmp.txt`: duchr `-i.backup` wird vor dem Ersetzen einen Kopie der Datei mit der Endung `.backup` erzeugt
- `sed '/\#/d' .bashrc` löscht alle Zeilen, in denen eine `\#` (Raute) vorkommt
- `grep -v '^\#' .bashrc | grep -v '^$'` 
- `sed -e '/^\#/d' -e '/^$/d' .bashrc` 
- `sed '1,103d .bashrc` löscht alle zeilen von 1-103
- `sed '1,10!d' .bashrc` löscht alle zeilen von 10 ab, das `!` invertiert hier die Bedeutung von `d` (Loeschen -> Anzeigen)
- mehrere _Skripte_ koenne mit `-e` hintereinander ausgeführt werden
- `sed -e '1,2p' -e '10,12!d' commands.txt` oder / `sed -n -e '3,9d' -e '1,12p' commands.txt` zeigt die nur die 1und 2. und 10-12 an 
- `sed 'y/#alias/Berts/' .bashrc`: `y` ersetzt 1 zu 1

### nl und tr
- `nl commands.txt` fügt jeder Zeile des Streams eine Zeilennummer hinzu
- `tr` = Zeichen übersetzen, zusammenfügren oder loeschen
- `tr` kann keine Datei übergeben werden, muss über Redirects/Umleitungen erfolgen
- `tr -s ' '` ersetzt mehrere direkt aufeinanderfolgende Leerzeichen durch ein einzelnes Leerzeichen
- `tr ',' ';'`: übersetzt ein `,` in ein ';'

### Hard- und Softlinks
#### Softlinks
- `ln -s orig1 link1` erstellt ein link von einer datei innerhalb eines ordners 
- `ln -s ~/.bashrc ~/links/bashrc-link` erstellt ein link von einer datei wenn die beiden dateien nicht im selben Verzeichniss sond müssen sie mit absolutem Pfad angegeben werden - `ln -s ~/compression-comparsion/ ~/links/compression-comparsion-link` um ein Verzeichniss soft zu verlinken 
- Softlinks haben immer komplette Berechtigung angezeigt haben aber die gleichen Rechte wie die Originale 
- ist ein Zeiger auf den Dateinamen einer Datei aber nicht auf den Speicher 

#### Hardlinks 
- macht kein Unterschied zwischen primärer Datei 
- ist ein weiterer Zeiger auf den Speicherbereich einer Datei im Speicher 
- Berechtigungen werden übernommen aber können beim Hardlink seperat geändert werden 
- Hardlinks können nicht auf Verzeichnisse angewendet werden da Verzeichnisse ja kein Zeiger auf einen Speicherbereich sondern nur einen Teil des Verzeichnissbereichs haben 

## Freitag

### Ausfühungsprioritäten Prozesse
- normale Prozesse - realtime Prozesse
- normale Prozesse Prioriäten von 100 bis 139
- realtime Prozesse von 0 bis 99
- `ps` zeigt Prioritäten von -40 bis 99, wir addieren also immer 40 dazu
- `top` zeigt Prioritäten von -100 bis 39, wir addieren alos immer 100 dazu
- `nice` kann einem Kommando beim Start eine geringere/hoehere Ausfühtungspriorität zugewiesen werden
  - Werte von -20 bis -1 koennen nur von `root` zugewiesen werden
  - Werte von 0 bis 19 von normalen Benutzern
  - ein hoeherer `nice` - Wert bedeute, dass der Prozess eine *geringere* Ausführungspriorität zugewiesen bekommt (Prozess ist weniger _nett_ zu anderen)
- `renice` kann einem Kommando im laufenden Betrieb eine andere Priorität zugewiesen werden
  - nur `root` kann `renice` ausführen

## Montag

### Shell-Skripte
- die erste Zeile eines Skripts beginnt mit dem sog. _Shebang_ (`#!`)
- hier wird der Interpreter angegeben (z.B. `sh`, `bash`, `php`, `python`, `perl` ...) der das Skript ausführen soll: `#!/bin/bash` bzw. mittlerweile bessere Syntax `/usr/bin/env bash`
- Skripte werden in einer eigenen Shell ausgeführt, die sich nach Beendigung wieder schliest (-> es koennen also z.B. keine Variablen aus einem Skript heraus exportiert werden)
- zum Ausführen müssen Ausführungsrechte gesetzt werden (z.B. `chmod +x mein-skript.sh`), Skript wird dann über eine Pfadangabe aufgerufen (z.B. `./mein-skript.sh`)
- Skripte koennen auch direkt einer Shell als Parameter übergeben werden um sie auszuführen (`bash mein-skript.sh`), so muss weder ein Interpreter / Shebang angegeben werden, noch Ausführungsrechte gesetzt werden

### Variablen
- `$0`: Name des Skripts 
- `$1`: erstes übergebenes Argument 
- `$2`: zweites übergebenes Argument 
- `$#`: Anzahl der Argumente
- `$*`: alle dem Skript übergebenen Argumente
- `$@`: alle dem Skript übergebenen Argumente, in Double Quotes (`"$@"`) wird auch jedes Argument in `""` gesetzt
- `$!`: PID des zuletzt ausgeführten Kommandos
- `$$`: PID der aktuellen Shell 
- `$?`: ExitCode / Rückgabewert des zuletzt ausgeführten Kommandos (alles ausser `0` ist ein Fehler)

#### if - else
- wird mit `if...then` eingeleitet und muss mit einem `fi` beendet werden
- else if ist `elif`

#### Syntaktische Elemente
- `&&` / `||`: logisches _UND_ bzq. _ODER_ (nur in _BASH_ und innerhalb von `[[ expr1 && expr2 ]]`)
- `-a` / `-o`: logisches _UND_ bzq. _ODER_ (in _SH_ und innerhalb von `[ expr1 -a expr2 ]`)
- `[[ ... ]]` ist eine Erweiterung von `[ ... ]` mit mehr/anderer Syntax
- in `[[ ... ]]` koennen auch reguläre Ausdrücke verwendet werden: `if [[ "$expr1" =~ regex ]]`
- `[ ... ]` ist die symbolische Schreibweise für das Kommando `test` (-> `man test`)
- bei `[ ... ]` unbedingt auf ein Leerzeichen zwischen `[` bzw. `]` und der/den `expr` achten (`if [ $var -eq $othervar ]; then ... fi`)
- auch müssen hier Variablen unbedingt in Anführungszeichen gesetzt werden (`if [ "$var" = 5 ]`)
- der Shell-Builiin `read` kann zum Einlesen von Benutzereingaben genutzt werden (`read -p "Eingabe: " answer`), Eingabe wird in Variable `answer` gespeichert

## Dienstag

### cron
- Dienst, der Aufgaben (`cronjobs`)zu einem bestimmmten Zeitpunkt oder Zeitintervall automatisch ausführt
- `cronjobs` werden nicht nachgeholt, sollte der Rechner zu dem angegebenen Zeitpunkt aus sein
- Aufgaben werden in `crontabs` festgelegt
- es gibt Benutzer `crontabs` für jeden Benutzer (auch `root`) und eine systemweite `crontab` unter `/etc/crontab`
- diese unterscheidet sich von den User-crontabs (nur) dadurch, dass es eine zusätzliche Spalte für den auszuführeden Benutzer enthält
- in den Verzeichnissen `/etc/cron.hourly`, `/etc/cron.daily` usw. koennen Skripte abgelegt werden, die dann periodisch ausgeführt werden
- je nach Distribution koenne die Verzeichnisse auch `/etc/cron.d/daily` etc. heissen
- User crontabs liegen unter `/var/spool/cron/crontabs`
- die User crontab Dateien werden nicht direkt editiert, sondern mit dem Kommando `crontab -e`
- `crontab -r` loescht die crontab des aufrufenden Benutzers
- `crontab -l` zeigt den Inhalt der crontab an
- `root` kann eine User crontab mit dem Kommando `crontab -u <user> -e / -l / -r` editieren, auflisten oder loeschen
- Informationen über den Aufbau und die Angabe von Zeiten/Intervallen sind in der Manpage zu finden: `man 5 crontab`
- in den Dateien `/etc/cron.allow` und `/etc/cron.deny` koenne Zugriffe auf den cron Daemon geregelt werden
- existiert die Datei `/etc/cron.allow` koennen _ausschliesslich_ die darin gelisteten Benutzer (einer pro Zeile) `cron` benutzen
- existiert die Datei `/etc/cron.deny` und *keine* `/etc/cron.allow` koennen alle nicht darin gelisteten Benutzer (einer pro Zeile) `cron` benutzen
- existieren beide Dateien, wird nur `/etc/cron.allow`

### systemd-timer
- `systemd-timer` sind eine Alternative von systemd für cron
- diese sind Unit Files mit der Endung `.timer`
- für jeden Timer *muss ein Unit File vorliegen*, welches den Unit beschreibt, der gesteuert wird
- standardmäßig haben Timer und Unit Files den gleichen Namne bis auf die Endung
- Aufbau Timer: (run the service named /etc/systemd/system/foobar.service at 05:30 on the first Monday of each month)

----
[Unit]
Description=Run the foobar service

[Timer]
OnCalendar=Mon *-*-1..7 05:30:00
Persistent=true

[Install]
WantedBy=timers.target
----
- Syntax/Aufbau Eintrag `OnCalendar=` ähnlich wie bei cronjobs
- generelle Syntax:

----
# DayOfWeek Year-Month-Day  Hour:Minute:Second
  Mon       *   - *    1..7 05:30:00

# Alternativ:
  hourly
  daily
  weekly
  monthly
  yearly
----

- `DayOfWeek` ist optional
- `*, /,` , wie in Cronjobs
- mit `..` kann eine Range angegeben werden
- es können auch monotonic timers verwendet werden
- werden nach Ablauf einer gewissen Zeit aktiviert
- `timer` müssen wie `services` aktiviert werde:

----
systemctl enable foobar.timer
systemctl start foobar.timer

# Alternativ:
systemctl enable --now foobar.timer
----
- anschliessend muss noch das Kommando `systemctl daemon-reload` ausgeführt werden


## Mittwoch

### Mail System

#### Mailsystem Komponenten

- MUA: Mail User Agent -> Mail Programme / Clients: Thunderbird, Evolution, kmail, (mail,) Outlook - Mails lesen, verfassen...
- MDA: Mail Delivery Agent -> verarbeitet Mails auf dem Server, entscheidet wo/wie sie an den Empfänger geleitet werden (lokale Zustellung/an Mailadresse): `procmail`, `cyrus`, `maildrop`
- MTA: Mail Transfer Agent ->  "eigentlicher Mailserver", zum Senden und Empfangen von Mails: Postfix, sendmail, exim (einfach zu konfigurieren), qmail (sicherer und einfacher zu konfigurieren als z.B. sendmail)

#### SMTP
- _Simple Mail Transfer Protocol_
- zum Empfangen von Mails
- Port 25

#### POP3 / IMAP
- zum Senden von Mails
- POP3: _kopiert_ Mails vom Server auf den Client, auf dem Client geloeschte Mails verbleiben auf dem Server (Port 110)
- IMAP: _synchronisiert_ Mails zwischen Server und allen Clients, auf einem Client geloeschte Mail wird auf dem Server und somit auf allen anderen Clients geloescht (143)

#### Aliase
- Definition in `/etc/aliases`
- vier Verfahren:
----
# user: user
root: tux 

# user: email
tux: tux@linux.org
tux: tux@linux.org, mail@tux.com, peter

# user: /absoluter/pfad/datei
tux: /home/tux/datei-in-die-mails-geschrieben-werden.txt

# user: programm
tux: '|/usr/bin/some-program.sh'

# user: datei-mit-adressen (eine pro Zeile)
tuxfreunde: :include:/home/tux/meine-freunde.txt
----
  
- nachher `sudo newaliases` ausführen (oder `sudo sendmail -bi`

#### Weiterleitung Benutzer
- im Heimatverzeichnis die Datei `.forward` erstellen
- Aufbau generell der selbe wie `/etc/aliases`, erste Spalte entfällt aber
- nach dem Speichern der Datei ist die Weiterleitung sofort aktiv

#### Dateien und Verzeichnisse
- `/var/spool/mail` (Symlink von `/var/mail`): hier liegen die Mails, ein Verzeichnis pro Benutzer
- `/var/spool/mqueue`: hier liegt die Mailqueue (Warteschlange)
- `/var/spool/postfix`: "Datenbankdateien" von Postfix
- `/etc/postfix`: Konfigurationsdateien von Postfix
- `/etc/postfix/main.cf`: Haupt-Konfigurationsdatei von Postfix
- `/etc/mail`: enthält die meisten Konfigutationsdateien von sendmail

#### Kommandos
- `mailq` zeigt die Mail-Warteschlange an
- `mail` bzw. `mailx` zum Lesen und Verfassen von Mails

#### Smarthost
- ein Smarthost ist ein Mailserver (vom ISP) , der als SMTP-Relay fungiert
- Mails werden so nicht direkt, sondern durch den SMTP-Server des ISPs ausgeliefert
- ansonsten würden die Mails von vielen Mailservern verworfen werden (→ mögliches Relay für Spam), da eigener SMTP-Server nicht im Internet bekannt ist

## Donnerstag

selbstständiges Arbeiten

## Freitag

selbstständiges Arbeiten

## Montag

### Ablauffristen Passwoerter
Ablaufdatum der Passwörter ändern

- `chage -m 2 karlos` karlos kann sein Passwort frühestens nach zwei Tagen ändern (-m minimum)
- `chage -M 21 karlos` karlos muss sein Passwort spätestens nach 21 Tagen ändern (-M Maximum)
- `chage -l karlos` Informatinen anzeigen

### Logging

#### rsyslog
- _klassischer_ Syslog
- Nachfolger von `syslog` und `syslog-ng`
- war Standard vor `journald`
- `/etc/rsyslog.conf` ist die Konfigurationsdatei für den _rsyslog_
- Aufbau: `facility:level action`
- `facility`: _Bereich_ aus dem das Logging kommt (`auth, authpriv, cron, daemon, kern, lpr, mail, mark, news, syslog, user, uucp, local0 bis local7`)
- `local0` bis `local7`: für Logging von eigenen Programmen/Skripten
- `level`: Protokollierungsgrad (`debug`, `info`, `notice`, `warn`, `err`, `crit`, `alert`, `emerg`)
- `action`: _Ziel_, in das protokolliert werden soll, meistens bestimmte Log-Datei

- die meisten Logs sind im Klartext 
- über Dateibereichtigungen wird der Zugriff geregelt
- Log Dateien werden unter `/var/log` abgelegt
- `/var/log/messages`
- `/var/log/syslog`

#### logrotate
- überwacht Logdateien, so dass der Speicherplatz begrenzt wird
- je nach Konfiguration werden mehrere (komprimierte) Dateien erstellt
- die mit der hoechsten Nummer ist die älteste
- Konfigurationsdatei unter `/etc/logrotate.conf`
- Verzeichnis `/etc/logrotate.conf.d` enthält spezielle Konfigurationsdateien für einzelne Dienste (z.B. `apache2`)
- Vorgehen:
  - aktuelle Log-Datei `my.log` wir umbenannt in `my.log.1`
  - neue leere Log-Datei `my.log` wird erstellt
  - vorhandene `my.log.1` umbenannt in `my.log.2` und komprimiert (`my.log.2.gz`)
  - usw.
  - älteste wird je nach Einstellung geloescht
- wird täglich von `cron` ausgeführt
- mit dem Kommando `logger` koennen selbst Ereignisse in den Syslog geschrieben werden (Skripte)

#### journald
- kommt unter `systemd` zum Einsatz
- übernimmt komplettes Logging
- Konfigurationsdatei unter `/etc/systemd/journald.conf`
  - `Storage`: wie Journal(s) gespeichert werden (s.u.)
  - `Compress`: grosse Objekt werden `xz` komprimiert
  - `SplitMode`: separate Journals pro User
  - `MaxFileSec`: Analogie zu `logrotate` -> wie lange sollen Einträge in einer Datei gespeichert werden bevor sie in die nächste rotiert wird
  - Groessenbeschränkung aber eher automatisch über selbstständige Prüfung des verbleibenden Speicherplatzes 
- unter `/var/log/journal` wird das Journal abgelegt
- muss in der Konfiguration mit `Storage=auto` oder `Storage=persistent` eingestellt sein
- ansonsten wird das Journal nur im Speicher vorgehalten, ist also nach einem Reboot weg
- `auto`: Verzeichnis `/var/log/journal` muss vorhanden sein, ansonsten Speicherung nur im RAM (bzw. unter `/run/log/journal`
- Journal ist eine Datenbank, keine Textdatei mehr
- Anzeige des Journals mit `journalctl`
- Ausgabe kann mit bekannten Tools wie `grep` durchsucht werden
- besser ist aber die Verwendung von Filtern
- `journalctl` bietet jede Menge miteinander zu kombinierende Filtermoeglichkeiten
- `journalctl -b`: alles seit dem aktuellen Boot 
- `journalctl -f`: Log live beobachten (-> `tail -f`) 
- `journalctl -e`: direkt ans Ende der Logs springen 
- `journalctl -r`: neueste Einträge zuerst
- `journalctl -n 20`: nur die letzten 20 Zeilen
- `journalctl -u apache2`: alle Logs des Units Apache2 
- `journalctl -since yesterday --until '2022-02-10 10:45'`: alle Einträge von gestern bis zum 10.02.2022 um 10:45 Uhr
- etc.
- siehe auch `man journalctl`
- `journalctl --vacuum-size=100MB`: beschneidet das Journal nachträglich auf eine Groesse von 10MB
- Groesse ungefähr, da zusammenhängende Logeinträge nicht getrennt werden
- daher nachher Konsistenzprüfung mit `journalctl --verify` noetig


## Dienstag

### Zeit(synchronisation) - ohne systemd

#### Uhrzeit
- wir haben zwei "Uhren" auf unserem System:
  - Systemuhr/-zeit (Software, Betriebssystem)
    - `date`
    - `date --set="11 Nov 2011 11:11:11"`
    - `date -s "11 Nov 2011 11:11:11"`
  - Hardwareuhr/-zeit (Motherboard) _RTC_
    - `hwclock`
- sollten syncronisiert werden
- die Systemzeit sollte die massgebliche Zeit sein:
  - `sudo hwclock --systohc`

#### Zeitzonen
- unter `/usr/share/zoneinfo` befinden sich die Zeitzonen (in Unterverzeichnissen), keine Textdateien
- sortiert nach _Kontinent_/_Stadt_
- um die Zeitzonen einzustellen, wird ein Symlink der Zeitzone unter `/usr/share/zoneinfo` auf `/etc/localtime` erstellt
- diese Einstellung betrifft nur die Systemzeit
- um die Zeitzone auch für die Hardwareclock zu übernehmen müssen die Uhren erneut synchronisisert werden mit `sudo hwclock --systohc`
- die aktuelle Zeitzonen findet sich auch in `/etc/timezone` (Textdatei)
- interaktives Auflisten der Zeitzonen mit `tzselect`
- für die aktuelle Shellsession kann die Zeitzone über die Variable `TZ` eingestellt werden: `TZ='America/Los_Angeles date`

### Zeit(synchronisation) - mit systemd
- Kommando `timedatectl` zum Anzeigen der Uhrzeit (Hard- und Systemuhr) und Zeitzone

#### Uhrzeit
- `sudo timedatectl set-time '2022-02-22 2:22:22'`

#### Zeitzonen
- werden mit `sudo timedatectl set-timezone Europe/Berlin` eingestellt (Autovervollständigung funktioniert)
- hierdurch wird analog zu oben ein entsprechender Symlink erstellt
- die Hardwareuht kann mit `sudo timedatectl set-local-rtc` synchronisiert werden
- hiervon wird aber bei der Verwendung von `systemd` abgeraten, Hardwareuhr sollte weiterhin unter _UTC_ laufen
- `tzconfig`
- `dpkg-reconfigure tzdata`

### NTP
- _Network Time Protocol_
- die Systemzeit wird über Server(pools) mit Refernzuhren abgeglichen
- Aufbau ist hierarchisch:
  - _Stratum 1_ sind nicht oeffentlich zugänglich, greifen direkt auf die Refernzuhren zu
  - _Stratum 2_ koenne auf Stratum 1 Maschinen zugreifen
  - _Stratum 3_ koenne auf Stratum 2 Maschinen zugreifen
  - _Stratum 4_ koenne auf Stratum 3 Maschinen zugreifen
  - ab _Stratum 2_ ist der Zugriff oeffentlich
- unser Rechner kontaktiert in der Regel _Stratum 4_ Maschinen

#### in diesem Zusammenhang wichtige Begriffe
- _Offset_: This refers to the absolute difference between system time and NTP time. For example, if the system clock reads 12:00:02 and NTP time reads 11:59:58, then the offset between the two clocks is four seconds.

- _Step_: If the time offset between the NTP provider and a consumer is greater than 128ms, then NTP will perform a single significant change to system time, as opposed to slowing or speeding the system time. This is called stepping.

- _Slew_: Slewing refers to the changes made to system time when the offset between system time and NTP is less than 128ms. If this is the case, then changes will be made gradually. This is referred to as slewing.

- _Insane Time_: If the offset between system time and NTP time is greater than 17 minutes, then the system time is considered insane and the NTP daemon will not introduce any changes to system time. Special steps will have to be taken to bring system time within 17 minutes of proper time.

- _Drift_: Drift refers to the phenomenon where two clocks become out of sync over time. Essentially if two clocks are initially synchronised but then become out of sync over time, then clock drift is occurring.

- _Jitter_: Jitter refers to the amount of drift since the last time a clock was queried. So if the last NTP sync occurred 17 minutes ago, and the offset between the NTP provider and consumer is 3 milliseconds, then 3 milliseconds is the jitter.

- deutsche ausführliche Version unter https://www.meinberg.de/german/info/ntp.htm

#### Kommandos und Dateien
- NTP Daemon: `ntpd`
- Konfigurationsdatei: `/etc/ntp.conf`
- `ntpq` oder `ntpdc`: Interaktive Abfragen

#### SNTP
- unter `systemd` wird _SNTP_ eingesetzt (_Simple Network Time Protocol_)
- geringerer Funktionsumfang, leichtgewichtiger, einfacher zu konfigurieren
- Zeit wird nur von einem einzigen Server bezogen
- hierfür muss `systemd-timesyncd` laufen

#### chrony
- alternative Implementation von NTP
- Dienst heisst `chronyd`
- CLI Interface heisst `chronyc`
- Konfigurationsdatei unter `/etc/chrony.conf`

## Mittwoch

### Printing

#### CUPS

- _CUPS_: Common Unix Printing Service
- Administration über Weboberfläche (`http://localhost:631`) oder über die Konfigurationsdatei `/etc/cups/cupsd.conf` bzw. CLI-Tools
- weitere Konfigurationsdatein unterhalb von `/etc/cups/`
- Druckwarteschlange unter `/var/spool/cups`
- es koennen Drucker hinzugefügt, entfernt, modifiziert werden, die Druckwarteschlange verwaltet, Drucker koennen lokal z.B. über USB oder über das Netzwerk angeschlossen sein

#### Kommandozeilentools
- folgende Programme funtionieren auch unter CUPS:
  - `lpr`: zum Drucken von Dateien: `lpr -P Samsung_ML-2160_Series somefile.txt`
  - `lprm`: Druckaufträge loeschen. Ohne Angabe von Optionen wird der aktuell aktive geloescht, `lprm -` loescht alle, `lprm 32` loescht Auftrag mit der Job ID 32
  - `cancel`: loescht den aktiven Auftrag des aufrufenden Benutzers
  - `lpq`: Druckerwarteschlange anzeigen `lpq -P Samsung_ML-2160_Series`
  - `lpc`: interaktiv, unter CUPS (nur eingeschränkt)
- für Prüfung nicht relevant:
  - `lpstat`
  - `lpadmin`: Drucker unter CUPS konfigurieren, z.B. Standarddrucker setzen etx.
  - `lpoptions`: Optionen von Druckern anzeigen und Standardwerte setzen
  - `lpinfo`: (deprecated) Verfügbare Drucker und Treiber anzeigen

### Lokalisierung und Internationalisierung
- über die Lokalisierung werden Einheiten, Zeichen usw. im länder-/gebietsspezifischen Format dargestellt (Meter - Inches, 24 Stunden Format - 12 Stunden Format etc.)
- die Datei `/etc/locale.conf` enthält Systemvariablen, über die die Lokalisierung definiert werden kann:
- `LC_CTYPE` - Zeichenklassifikationen
- `LC_COLLATE` - Sortierreihenfolge
- `LC_TIME` - Zeit- und Datumsformat
- `LC_NUMERIC` - numerische Formate außerhalb des Finanzsektors
- `LC_MONETARY` - numerische Formate des Finanzsektors
- `LC_MESSAGES` - Formate für informative und diagnostische Benachrichtigungen
- `LC_PAPER` - Papierformate
- `LC_NAME` - Namenformate
- `LC_ADDRESS` - Adressformate
- `LC_TELEPHONE` - Formate der Telefonnummern
- `LC_MEASUREMENT` - Maßeinheiten (metrisch oder andere)
- `LC_IDENTIFICATION` - Metadaten der Lokalisation
- `LC_ALL` - wenn gesetzt (normalerweise nicht) werden alle anderen Variablen überschrieben
- `LANG` - geringe Priorität, nur Auswirkungen wenn keine anderen gesetzt
- `LANG=C` - nützlich z.B. in Skripten bei Sortierungen o.Ä., Daten werden nicht anhand der jeweiligen Zeichentabelle sonder roh/raw sortiert
- verfügbare _locale_ unter `/usr/share/i18n/locale`
- `locale -a` zeigt alle verfügbaren Lokalisierungen an
- `locale -m` zeigt alle verfügbaren Zeichensätze an
- `localectl` anzeige der Lokalisierungen, Keyboardeinstellungen
- `localectl set-locale en_US.UTF-8`
- `localectl set-locale LC_MESSAGES=en_US.utf8`
- `localectl set-locale LC_MESSAGES=en_US.UTF-8`
- `localectl list-locales`
- `iconv -f ISO-8859 -t UTF-8 my-iso-encoded-file -o my-utf8-encoded-file`

### Clientseitiges DNS

- in der Datei `/etc/nsswitch.conf` findet eine Zuweisung von Quellen zur Namensaufloesung und Anwendugen statt
- die angegebenen Services werden der Reihenfolge nach abgearbeitet
- es koennen einfache logische Ausdrücke verwendet werden (`resolve [!UNAVAIL=return] dns`: ist DNS also nicht nicht-vorhanden wird nicht die nächste Methode angewandt, sondern abgebrochen)
- `/etc/resolve.conf`: 
  - kann bis zu drei `nameserver` Einträge enthalten
  - `search`: bei lokalen Anfragen kann der hier definiert Teil der URL weggelassen werden 
    - `search lpi.org` -> Eingabe von `learning` anstatt `learning.lpi.org` reicht aus
  - `domain`: hier wird die Domäne definiert, kann wie `search` auch für die Kurzsuche verwendet werden, sind beide vorhanden, gilt nur der letzte Eintrag
- `/etc/hosts`: lokale Namensaufloesung, Vorläufer DNS
- `systemd-resolved`: kein vollwertiger DNS Server, lauscht wenn gestartet an `127.0.0.53`, Konfiguration unter `/etc/systemd/resolved.conf`
- `getent`: zur Abfrage von datenbankartigen Dateien, Ausgabe wie `grep`
- `host`: Namen in IP Adressen aufloesen
- `host -t MX`: nur die MX-Records anzeigen
- `dig`: ausführliche Informationen über angefragte URL
- Ausgabe kann gut angepasst werden (Filterung nach Records usw.)
- `dig +short lpi.org`: nur Ergebnis, keine weitere Ausgabe

## Donnerstag

### X-Server

#### Aufbau von X
##### Client-Server-Applikation

- Kommunikation zwischen X-Server und X-Client durchläuft immer Netzwerkschicht

##### X-Server
- kommuniziert mit der Hardware (Grafikkarte)
- nimmt Eingaben von der Tastatur entgegen
- hat keinen Einfluss auf das Aussehen der Anwendungsprogramme
- nur für Ausgabe zuständig
- kann auf entfernter Maschine im Netzwerk laufen

##### X-Client
- kommuniziert mit dem X-Server
- genauer: ist ein Anwendungsprogramm (Browser, Mail-Client ...)

##### Windowmanager
- ist ein X-Client
- ist für das Aussehen der Fenster und Schaltflächen zuständig
- Beispiele: KWin, Metacity, Windowmaker, FVWM95, i3, twm ...

##### Displaymanager
- für Authentifizierung von Benutzern und Starten der grafischen Umgebung zuständig

##### Desktop Environment
- vorkonfigurierte Ansammlung von Anwenderprogrammen, Windowmanager und Displaymanager
- Beispiele: KDE, GNOME, LXDE, Xfce, Cinnamon, Mate …​
- KDE: KWin und kdm
- GNOME: Metacity (ältere Sawfish) und gdm

#### Startvorgang von X
- `startx`: Frontend für Startskript `xinit`
- bezieht zusätzliche Skripte mit ein
- typischerweise:
  - `xinitrc` Startskript für xinit
  - `xserverrc` Startskript für den X-Server
- unter /etc/X11` liegen die systemweiten Dateien, werden nur ausgelesen, falls keine benutzerspezifische existiert
- `xinit`: zuständig für die eigentliche Initialisierung von X-Window
- `xinitrc`: welche X-Clients und welcher Windowmanager werden gestartet
- aus dieser Datei heraus gestartete Programme sollten immer in den Hintergrund geschickt werden (&)

#### X-Libraries
- dynamische Bibliotheken für grafische Programme
- bei GNOME: Bibliotheken aus dem GTK (GIMP Toolkit)
- bei KDE: QT Libraries

#### `xorg.conf`
- Hauptkonfigurationsdatei des X-Servers
- inkludiert Dateien unter `/etc/X11/xorg.conf.d`
- unterteilt in Sektionen:

##### Section Files
- Pfade, die der Server zum Betrieb benötigt
- Fontpath Verzeichnisse für Fonts
- RgbPath Datei, in der Farbbezeichnungen in RGB-Werte übersetzt werden

##### Section Server-Flags
- globale Einstellungen für den X-Server (Power-Management, Hotkeys...)

##### Section Input Device
- Tastatur und Maus
- kommt mehrfach vor wegen Übersichtlichkeit

##### Section Monitor und Modes
- Section Monitor: technische Daten Monitor(e)
- Section Modes: mögliche verwendbaren Videomodi

##### Section Device
- Angaben über Grafikkarte

##### Section Screen
- führt Grafikkarten und Monitor(e) zusammen → Screen
- daher eindeutiger Bezeichner (Identifier) sowohl für Grafikkarte als auch für Monitor

##### X-Fontserver
- zentrale Verwaltung von Fonts
- `/etc/X11/fs/congig`

##### X-Display exportieren
- Positionierung Benutzer ungewohnt: sitzt am Server, Client an einem anderen Ort
- Serverseitige Maßnahmen: X-Server muss Zugriff auf sein Display durch X-Client erlauben:

----
xhost + bzw. xhost +hostname-client
----

- Zugriff verbieten mit `xhost -` bzw. `xhost -hostname-client`
- Clientseitige Maßnahmen: dort wo CLient-Programm ausgeführt werden soll muss DISPLAY - Variable geändert werden (Umleitung auf X-Server)

- `xdpyinfo`: Informatinen über den installierten X-Server

#### Wayland
- Neuentwicklung des X-Servers (komplett andere Architektur, Programme müssen portiert werden

### Netwerkkonfiguration
- `nmcli`: CLI Programm für NetworkManager
- `nmtui`: TUI Programm für NetworkManager
- `ip`: moderne Toolbox zur Netzkoniguration (Anzeige Interfaces/Routen/Tunnel/Neighbours)
- mit `ip` kann ein Interface (dynamisch) konfiguriert werden (IP Adresse zuweisen, Standardgateway setzten usw.)
- `ifup`, `ifdown`: Interfaces, die in  `/etc/netwokr/interfaces` definiert sind hoch- bzw. herunterfahren (auf RedHat basierten System solche, die in `/etc/sysconfig/network-scripts`
- `/etc/network/interfaces`: Statische (einen Reboot überstehende) Netzwerkkonfiguration unter Debian basierten Systemen
- Legacy Tools: `ifconfig`, `route` (aus dem Paket `net-tools`)

### Network Troubleshooting
- `ping`: nutzt das ICMP Protokoll um kleine Datenpakete ans Ziel zu senden um so die Erreichbarkeit und "Reaktionszeit" zu ermitteln
- `ping -c 5` sendet nur 5 Pakete (`--count`)
- `traceroute`: sendet jeweils drei Pakete zu jedem Hopp auf dem Weg zum Ziel und misst die Dauer/Latenz, die die Pakete bis zum jeweiligen Hopp brauchen
- standardmässig Begrenzung auf 30 Hopps
- Standardprotokoll ist UDP
- andere Protokolle: `-T` für TCP, `-I` für ICMP
- nützlich, falls bestimmte Protokolle geblockt werden (von irgend einem Server auf dem Weg oder dem Ziel selbst)
- `tracepath`: ähnlich wie `traceroute`, hier wird aber die maximale Paketgroesse (MTU) bestimmt, auch ohne root Rechte zu nutzen
- `netstat`: Diagnoseprogramm zum Anzeigen der aktuellen Verbindungen (offene Ports, Dienste dahinter ...)
- `netstat -tulpen`: alle offenen TCP und UPD Ports, im Status LISTENING, ausführendes Kommando, keine Namensaufloesung dafür, erweiterte Ansicht
- `netstat -s`: Detailierte Ausgabe / Statistik 
- `netstat -r`: Ausgabe der Routingtabelle
- `ss`: Neuentwicklung, greift direkt auf den Kernel zu, dadurch schneller, viele Optionen gleich
- `netcat`: das _Schweizer Taschenmesser_, CLI Programm zur Netzwerkdiagnose
- kann beliebige Datenpakete versenden und Empfangen
- so koenne z.B. Dateien übertragen werden oder auch eine Reverse Shell gestartet werden

#### `hostnamectl`
- Anzeige und Setzen des Hostnamens (-> `/etc/hostname`) 

## Montag
### Umask
- legt fest, mit welchen Berechtigungen neu erstellte Dateien oder Verzeichnisse versehen werden
- die in der Umask gesetzten Bits werden nicht vergeben (von den sinnvollen Vollberechtigungen "substrahiert")
- bei Dateien sind die sinnvollen Vollberechtigungen `666`, bei Verzeichnissen `777`
- Bsp.: umask 022 -> Dateien 644, Verzeichnisse 755 (kein Schreibsrecht für Gruppe und Others)
- Bsp.: umask 023 -> Dateien 644, Verzeichnisse 754 

### Sonderbits
- *SUID*: wenn auf eine ausführbare Binärdatei gesetzt, wird das Kommando nicht mit den Rechten des aufrufenden Benutzer ausgeführt wird, sondern mit denen des Besitzers der Datei. Bsp.: `passwd` (editiert `/etc/shadow`)
- *SGID*: wenn auf eine ausführbare Binärdatei gesetzt, ähnlich wie das `SUID` Bit: das Kommando wird mit den Rechten der Gruppe ausgeführt, wenn auf ein Verzeichnis gesetzt, werden alle neu darin erstellten Dateien der Gruppe zugeordnet
- *StickyBit*: auf ein Verzeichins gestzt, kann nur noch der Besitzer der Datei oder `root` diese verändertn oder löschen. Bsp.: `/tmp`
- `rwsrw-rw-`: SUID Bit und Execute Bit für Besitzer gesetzt
- `rwSrw-rw-`: SUID Bit aber kein Execute Bit für Besitzer gesetzt
- `rw-rwsrw-`: SGID Bit und Execute Bit für Gruppe gesetzt
- `rw-rwSrw-`: SGID Bit aber kein Execute Bit für Gruppe gesetzt
- `rwxrwxrwt`: Sticky Bit und Execute Bit für Others gesetzt
- `rwxrwxrwT`: Sticky Bit aber kein Execute Bit für Others gesetzt

### at
- führt Aufgaben einmalig zu einem bestimmten Zeitpunkt aus
- kann interaktiv verwendet werden oder über Optionen
- Bsp.: `at now +2 minutes touch datei1`
- Bsp.: `at teetime tomorrow touch feierabend.txt`
- `atq` oder `at -l` zeigt ausstehende Jobs an
- `atrm ID` oder `at -r ID` / `at -d ID` löscht Job mit ID
- Zugangssteuerung durch `at.allow` und `at.deny`

### systemd-run
- systemd Alternative zu `at`
- `systemd-run --on-calendar="2022-03-07 15:34" touch datei3`
- `systemd-run --on-active="2min" touch datei4`




